<!DOCTYPE html>
<html lang="pl">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Doom Mod Patcher</title>
<style>
  body { font-family: system-ui, sans-serif; max-width: 760px; margin: 2rem auto; padding: 0 1rem; }
  .card { border: 1px solid #ccc; border-radius: 12px; padding: 1rem 1.25rem; }
  code { background: #f4f4f4; padding: 0.1rem 0.3rem; border-radius: 4px; }
  button { margin-top: 0.8rem; padding: 0.6rem 1rem; cursor: pointer; }
  #status { margin-top: 1rem; font-weight: 600; }
</style>
</head>
<body>
  <h1>Doom Mod Patcher</h1>
  <div class="card">
    <p>Wybierz <code>doom.wad</code>. Program sprawdzi SHA-256 i zastosuje binarną łatkę podzieloną na 16 części.</p>
    <input type="file" id="fileInput" accept=".wad,application/octet-stream">
    <br>
    <button id="patchBtn">Sprawdź i patchuj</button>
    <p id="status" aria-live="polite"></p>
  </div>

<script>
const PART_COUNT = 16;
const DEPLOY_VERSION = "2026-02-18-2";

async function sha256(buffer) {
  const hash = await crypto.subtle.digest("SHA-256", buffer);
  return Array.from(new Uint8Array(hash)).map(b => b.toString(16).padStart(2, "0")).join("");
}

async function fetchExpectedHash() {
  const res = await fetch(`hash.txt?v=${DEPLOY_VERSION}`, { cache: "no-store" });
  if (!res.ok) {
    throw new Error("Nie udało się pobrać hash.txt");
  }
  return (await res.text()).trim().toLowerCase();
}

async function fetchPatchMask() {
  const parts = [];
  for (let i = 1; i <= PART_COUNT; i++) {
    const num = i.toString().padStart(2, "0");
    const filename = `patch${num}.bin?v=${DEPLOY_VERSION}`;
    const res = await fetch(filename, { cache: "no-store" });
    if (!res.ok) {
      throw new Error(`Brak pliku ${filename}`);
    }
    const part = new Uint8Array(await res.arrayBuffer());
    parts.push(part);
  }

  const totalLen = parts.reduce((sum, p) => sum + p.length, 0);
  const merged = new Uint8Array(totalLen);
  let offset = 0;
  for (const part of parts) {
    merged.set(part, offset);
    offset += part.length;
  }
  return merged;
}

function applyXorPatch(originalBytes, maskBytes) {
  if (originalBytes.length !== maskBytes.length) {
    throw new Error(`Rozmiar doom.wad (${originalBytes.length} B) nie zgadza się z rozmiarem łatki (${maskBytes.length} B).`);
  }

  const output = new Uint8Array(originalBytes.length);
  for (let i = 0; i < originalBytes.length; i++) {
    output[i] = originalBytes[i] ^ maskBytes[i];
  }
  return output;
}

async function patch() {
  const statusEl = document.getElementById("status");
  const patchBtn = document.getElementById("patchBtn");
  const file = document.getElementById("fileInput").files[0];

  if (!file) {
    alert("Wybierz plik doom.wad");
    return;
  }

  patchBtn.disabled = true;

  try {
    statusEl.textContent = "Liczenie SHA-256 oryginalnego doom.wad...";
    const originalBuf = await file.arrayBuffer();
    const originalBytes = new Uint8Array(originalBuf);
    const userHash = await sha256(originalBuf);

    const expectedHash = await fetchExpectedHash();
    if (userHash !== expectedHash) {
      statusEl.textContent = "Hash się nie zgadza — to nie jest oczekiwany oryginalny doom.wad.";
      return;
    }

    statusEl.textContent = "Hash poprawny. Ładowanie części łatki...";
    const patchMask = await fetchPatchMask();

    statusEl.textContent = "Modyfikowanie bitów (XOR)...";
    const patchedBytes = applyXorPatch(originalBytes, patchMask);

    const blob = new Blob([patchedBytes], { type: "application/octet-stream" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "doom_mod.wad";
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);

    statusEl.textContent = "Gotowe! Pobieranie doom_mod.wad rozpoczęte.";
  } catch (err) {
    statusEl.textContent = `Błąd: ${err.message}`;
  } finally {
    patchBtn.disabled = false;
  }
}

document.getElementById("patchBtn").addEventListener("click", patch);
document.getElementById("status").insertAdjacentText("beforeend", `Wersja deploy: ${DEPLOY_VERSION}`);
</script>
</body>
</html>
